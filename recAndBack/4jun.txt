// wordbreak1official

	public static void wordBreak(String str, String ans, HashSet<String> dict){
		// write your code here
		
		if( str.length() == 0 ){
		    System.out.println(ans);
		    return;
		}
		
		for(int i=0 ; i<str.length() ; i++){
		    
		    String left = str.substring(0,i+1);
		    String right = str.substring(i+1);
		    if( dict.contains( left ) ){
		        wordBreak( right, ans + left + " " , dict);
		    }
		}
		
	}

--------------------------------------------------------------------------------------

// Remove Invalid Parenthesis

public static void solution(String str, int minRemoval, HashSet<String> ans) {
		//write your code here
		
		if( minRemoval == 0 ){
		    
		    if( getMin(str) == 0 ){
		        if( !ans.contains(str) ){
		            System.out.println(ans);
		            ans.add(str);
		        }
		    }
		}
		
		for(int i=0 ; i<str.length() ; i++){
		    
		    String left = str.substring(i);
		    String right = str.substring(i+1);
		    
		    solution( left+right , minRemoval-1, ans  );
		}
	}

// 	public static int getMin(String str){
// 		//write your code here
		
// 		Stack<Character> st = new Stack<>();
		
// 		for( int i=0 ; i<str.length() ; i++ ){
// 		    char c = str.charAt(i);
		    
// 		    if( c == '(' ){
// 		        st.push(c);
// 		    }else{
// 		        if( st.size() == 0 || st.peek() == c ){
// 		            st.push(c);
// 		        }else{
// 		            st.pop();
// 		        }
// 		    }
// 		}
		
// 		return st.size();
// 	}

    public static int getMin(String str){
		//write your code here
		
		// Stack<Character> st = new Stack<>();
		int ans = 0, o=0 , c=0;
		for( int i=0 ; i<str.length() ; i++ ){
		    char ch = str.charAt(i);
		    
		    if( c == '(' ){
		        // st.push(ch);
                o++;
		    }else{
		        // if( st.size() == 0 || st.peek() == ch ){
                if( o == 0 ){
		            // st.push(ch);
                    ans += 1;
		        }else{
                    o--;
		            // st.pop();
		        }
		    }
		}
		
		return o+ans;
	}


--------------------------------------------------------------------------------------

// largest-number-at-most-k-swaps-official

public static void findMaximum(String str, int k) {
		//write your code here
		
		if( k==0 ){
		 return;   
		}
		
		if( Integer.parseInt(max) < Integer.parseInt(str) ){
		    max = str;
		}
		
		
		for(int i=0 ; i<str.length() ; i++){
    		for(int j=i+1 ; j<str.length() ; j++){
		    
		        if( str.charAt(i) < str.charAt(j) ){
		            str = swap(str,i,j);
		            findMaximum( str, k-1 );
		            str = swap(str,i,j);
		        }
		    
    		}
		    
		}
		
		
	}


--------------------------------------------------------------------------------------

// Minimum Subset Sum Difference
// tug-of-war-official

public static void solve(int[] arr, int vidx, ArrayList<Integer> set1, ArrayList<Integer> set2, int soset1, int soset2) {
		//write your code here
		
		int n = arr.length;
		if( vidx == n ){
		
            int cur  = Math.abs( soset1 - soset2) ;
	        if(  cur < mindiff ){
              mindiff = cur;
              ans = set1 + " " + set2;
            }
		    return;
		}
		if( set1.size() < (n+1)/2 ){
            
            set1.add( arr[vidx] );
            solve(arr, vidx+1, set1, set2, soset1+arr[vidx], soset2);
            set1.remove( set1.size()-1 );
		}
		
        if( set2.size() < (n+1)/2 ){
            set2.add( arr[vidx] );
            solve(arr, vidx+1, set1, set2, soset1, soset2+arr[vidx]);
            set2.remove( set2.size()-1 );
        }    
    }

--------------------------------------------------------------------------------------

 //permutation-i-official

 public static void permutations(int[] boxes, int ci, int ti){
    // write your code here
    
    if( ci > ti){
        
        for(int i : boxes)
            System.out.print(i);
        
        System.out.println();
        
        return;
    }
    
    for( int i=0 ; i<boxes.length ; i++ ){
        if( boxes[i] == 0 ){
            
            boxes[i]  = ci;
            permutations( boxes, ci+1, ti );
            boxes[i]  = 0; 
        }
    }
    
  }
  --------------------------------------------------------------------------------------

  combinations-i-official


  public static void combinations(int cb, int tb, int ssf, int ts, String asf){
    // write your code here
    
    if( cb == tb+1 ){
        // System.out.println( cb+1 );
        if( ssf == ts )
        System.out.println( asf );
        return;
    }
    
    if( ts > ssf ){
        combinations( cb+1, tb, ssf+1, ts, asf + "i" );
    }
    
    combinations( cb+1, tb, ssf, ts, asf + "-" );    
  }

--------------------------------------------------------------------------------------

//  permutations-ii-official

   public static void permutations(int cb, int tb, int[] items, int ssf, int ts, String asf){
    // write your code here
    
    if( cb == tb+1 ){
        if( ssf == ts )
            System.out.println(asf);
            
        return;
    }
    
    
    // in prev we were puttin in box arr
    // but here we maintain arr for used nums
    for( int i=0; i<ts ; i++ ){
        
        if( items[i] == 0 ){
            
            items[i] = 1;
            permutations( cb+1, tb, items, ssf+1, ts, asf + (i+1) );
            items[i] = 0;
            
        }
    }
    permutations( cb+1, tb, items, ssf, ts, asf + 0 );
    
  }

---------------------------------------------------------------------------------------

// combinations-2-official


public static void combinations(boolean[] boxes, int ci, int ti, int lb){
	
    // write your code here
    
    if( ci == ti+1 ){
        
        for(boolean a: boxes){
            System.out.print( a?"i" : "-" );
        }
        System.out.println();
        return;
    }
    
    // premutation to combination
    // we use boolean arr to mark the used pos and iterate cur arr from the next i in next rec
    for( int i=lb+1 ; i<boxes.length ; i++ ){
        
        if( boxes[i] == false ){
            boxes[i] = true;
            combinations( boxes, ci+1, ti, i );
            boxes[i] = false;
        }
    }
    
  }